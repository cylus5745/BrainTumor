from __future__ import division
from scipy import signal
from sklearn import cluster

import operator
import os
import nibabel as nb
import h5py

import numpy as np
import scipy.ndimage as nd
import matplotlib.pyplot as plt
import logging as log

###########################################################################
# This program takes th MRI images provided in the <data_path=STRING> and #
# 1. Identified the tumor region if present in each of those regions      #
# 2. Saves the binary_masks of those tumors 							  #
# 3. Validates the extracted tumor region by comparing with the results   #
#    provided by the radiologists in the original tumor dataset			  #
###########################################################################

###########################################################################
# Defining the functions:												  #
# IO functions															  #
#-------------------------------------------------------------------------#

## TESTED OK!
def get_ordered_file_names(dir_path, suffix):
	""" <suffix=STRING> is the file extention of the files in <dir_path=STRING> """
	files=os.listdir(dir_path)

	# extract the numbers from file names
	sorted_int=[]
	sorted_str=[]
	temp=[]
	for f in files:
		temp=f.split('.')
		sorted_int.append(int(temp[0]))
	sorted_int.sort(key=int)

	# concatenate the full path after numerically sorting the files in the folder
	for s in sorted_int:
		temp=dir_path+str(s)+suffix
		sorted_str.append(temp)

	return sorted_str

## TESTED OK!
def get_nb_image(abs_file_path):
	""" loads <abs_file_path=STRING> as file path and returns as NDARRAY """

	nb_obj=nb.load(abs_file_path)

	return (nb_obj.get_data())

## TESTED OK!
def save_as_Nifti(image, save_path):
	""" Saves <image=NDARRAY> in NIFTI format in <save_path=STRING > """
	# Saving them in Nifti format to use them in skull stripping
 	image_nb=nb.Nifti2Image(image, affine=np.eye(4))
 	nb.save(image_nb, save_path)


# # has ISSUES
def load_HDF5(abs_file_path, field):
	""" Returns the value of <field=STRING> in the <abs_file_path=STRING>
		return object depends on the field chosen

		'image' : NDARRAY shape(512,512)
		'tumorMask': NDARRAY binary_values shape(512,512), a binary image with 1s indicating tumor region
		'tumorBorder': a vector storing the coordinates of discrete points on tumor border.
		For example, [x1, y1, x2, y2,...] in which x1, y1 are planar coordinates on tumor border.
		It was generated by manually delineating the tumor border. So we can use it to generate
		binary image of tumor mask.
		'PID': patient IDcjdata.label: 1 for meningioma, 2 for glioma, 3 for pituitary tumor
		'label': 1 for meningioma, 2 for glioma, 3 for pituitary tumor
	"""
	f=h5py.File(abs_file_path)

	if field=='image':
		return (f['cjdata/image'])

	elif field=='tumorMask':
		return (f['cjdata/tumorMask'][()])

	elif field=='tumorBorderer':
		return (f['cjdata/tumorBorder'][()])

	elif field=='label':
		return (f['cjdata/label'][()])

	elif field=='PID':
		return (f['cjdata/PID'][()])

	else:
		print('INCORRECT FIELD passed for the HDF5 file object. '+field+' does not exist')

def get_file_number(file_):
	temp=file_.split('/')
	temp=temp[-1]
	temp.split('.')
	return (int(temp[0]))

#--------------------------------------------------------------------------#
# Image Filtering Methods												   #
#--------------------------------------------------------------------------#
sd=1.5	# Standard deviation
weight=0.25	# For unsharp masking and IHC

## TESTED OK!
def median_filtering(image):
	"""
	1. Applys median filter over an <image=NDARRAY>
	2. Then sharpens the output of the previous step to recover edge data
	"""
	# Applying median filter to the image
	image_med = signal.medfilt(image)
	# Sharpenening the image as median filter removes noise and smoothens the edges
	# So, applying Unsharp masking
	#BEGIN
	blurred = nd.gaussian_filter(image_med, sd)
	sharp_image = image_med - weight*blurred
	#END

	return (sharp_image,image_med)

## TESTED OK!
def IHC(image):
	""" Homogenises the pixel values accross to remove variences in them """
	# Inhomogeniety Correction (IHC)
	# 1. Correcting Intensity Homogeniety
	gaussian_filtered=nd.gaussian_filter(image,sd)
	# 2. To retain edge data
	edge=nd.sobel(gaussian_filtered)
	# 3. Adding gaussian_filtered+edge to achive IHC
	final=gaussian_filtered+weight*edge
	# 4. Applying thresholding on final to remove negetive pixel values
	flat_final=final.flatten()
	for j in range(0,262143):
		if flat_final[j]<0:
			flat_final[j]=0
	final=np.reshape(flat_final,(512,512))

	return (final)

## TEST pending
def skull_stripping(abs_image_path, abs_save_path):

	threshold=np.mean(image)/1000
	print('--> LOG: mean calculated for '+ abs_image_path +' :'+str(threshold))

    #Running fsl-BET2 Robust brain extraction tool
	print('--> LOG: Running fsl-BET2 Robust brain extraction tool')

    ## !!!!!!!!!-------------- WARNING-------------!!!!!!!!!!
    # WANING: remove the option that outputs the braim mask
	bashcmd='bet'+' '+abs_image_path+' '+abs_save_path+' '+'-R -f'+' '+str(threshold)+' '+'-g 0 -c 0256 0256 0 -m -t'
	print('--> LOG: handover to fsl')
	os.system(bashcmd)
	print('--> LOG: return from fsl ...')

#-------------------------------------------------------------------------#
# Calculating IVIFS / generating the feature vector						  #
#-------------------------------------------------------------------------#
# PRAMETERS used in these functions below are INITIALIZED here
lamda=0.8 # generate_nonmembership()
p=0.1
q=0.1
a=0.1
b=0.1

## TESTED OK!
def generate_fs(Image):
	""" this function takes in an Image of shape (512,512) and generates fuzzy values
	<Image_fs>for each pixel of the Image """

	if np.shape(Image)==(512,512):

		gl_max=np.amax(Image) 	# MAXIMUM gray level in the Image
		gl_min=np.amin(Image)	# MINIMUM gray level in the Image

		return (Image-gl_min)/(gl_max-gl_min)
	else:
		log.warning('shape of the Image passed to <generate_fs()> is INVALID!')

## TESTED OK!
def generate_membership(Image_fs):
	""" this function accepts Image and its corresponding fuzzy set and generates the membership
	values for each pixel based on the input parameters"""
	if np.shape(Image_fs)==(512,512):

		mean=np.mean(Image_fs)
		membership_val=0.582*((np.exp(1-abs(Image_fs-mean)))-1)
		print('MAX Mem: ', np.amax(membership_val), '\n MIM mem: ', np.amin(membership_val))

		# Thresholding as few values are greater than 1
		for i in range(512):
			for j in range(512):
				if membership_val[i,j]>1:
					membership_val[i,j]=1

		if np.amin(membership_val)<0 or np.amax(membership_val)>1:
			log.warning('Value Error: membership value out of range')

		else:
			return (membership_val)

	else:
		log.warning('shape of the Image passed to <generate_membership()> is INVALID!')

## TESTED OK!
def generate_nonmembership(Membership_value):

	if np.shape(Membership_value)==(512,512):
		nonmembership=(1-Membership_value)/(1+lamda*Membership_value)

		if np.amin(nonmembership)<0 or np.amax(nonmembership)>1:
			log.warning('Value Error: nonmembership value out of range')
		else:
			return nonmembership
	else:
		log.warning('shape of the Image passed to <generate_nonmembership()> is INVALID!')

## TESTED OK!
def generate_hesitation(Membership_value,Nonmbership_value):

	if (np.shape(Membership_value)==(512,512) and np.shape(Nonmbership_value)==(512,512)):
		hesitation=(1-Membership_value-Nonmbership_value)

		if np.amin(hesitation)<0 or np.amax(hesitation)>1:
			log.warning('Value Error: hesitation value out of range')
		else:
			return hesitation
	else:
		log.warning('shape of the Image passed to <generate_hesitation()> is INVALID!')

## TESTED OK!
def calc_IVIFS(IMG):
	fs_=generate_fs(IMG)
	mem_=generate_membership(fs_)
	non_=generate_nonmembership(mem_)
	hes_=generate_hesitation(mem_, non_)

	# Flattening the arrays for better representation
	mem_=mem_.flatten()
	non_=non_.flatten()
	hes_=hes_.flatten()

	fv_=[]
	# calculating memL memU nonL nunU memW nonW
	fv_.append(mem_-p*hes_)
	fv_.append(mem_+a*hes_)
	fv_.append(fv_[1]-fv_[0])
	fv_.append(non_-q*hes_)
	fv_.append(non_+b*hes_)
	fv_.append(fv_[4]-fv_[3])

	fv_=np.asarray(fv_)
	fv_=fv_.transpose()

	return(fv_)

#------------------------------------------------------------------------#
# Classifier validation functions										 #
#------------------------------------------------------------------------#
def get_tumor_mask(labels, cluster_number):
	i=0
	j=0

	tumor=np.zeros((512,512))

	# print(tumor_label)

	for k in range(len(kmeans.labels_)):
		if kmeans.labels_[k]==cluster_number:
			tumor[i,j]=1

		# up dating i,j to reshape into (512,512)
		j=j+1
		if j==512:
			j=0
			i=i+1

	# Applying H-max transform
	tumor=nd.grey_erosion(tumor,(3,3))

	return tumor

def evaluate(ext_mask, true_mask):

	tp=0
	fp=0
	fn=0

	ext_mask=ext_mask.flatten()
	true_mask=true_mask.flatten()

	for i in range(262144):
		if ext_mask[i]==true_mask[i]:
			tp=tp+1

		elif (ext_mask[i]==1) and (true_mask[i]==0):
			fp=fp+1

		elif (ext_mask[i]==0) and (true_mask[i]==1):
			fn=fn+1

		else:
			pass

	dice= tp/262144
	precision= tp/(tp+fp)
	recall= tp/(tp+fn)
	print('TP, FP, FN : ', tp, fp,fn)
	return(dice, precision, recall)

###############-----TEST-----###################

#
# cluster_choice=0
#
# IMG=get_nb_image('/root/projects/BrainTumor/brain/2000.nii.gz')
#
# IVIFS = calc_IVIFS(IMG)
#
# print(np.shape(IVIFS))
#
# kmeans=cluster.KMeans(n_clusters=4).fit(IVIFS)
#
# labels=kmeans.labels_
#
# i=0
# while cluster_choice==0:
# 	mask=get_tumor_mask(labels,i)
# 	i=i+1
# 	plt.imshow(mask)
# 	plt.show()
# 	cluster_choice = int(input('Enter 1 if right cluster, 0 otherwise: '))
#
#
#
# # plt.gray()
# # plt.imshow(mask)
# # plt.show()
#
# # f = h5py.File('/root/projects/BrainTumor/dataset/1871.mat')
# # tru_mask=f['cjdata/tumorMask'][()]
#
# tru_mask=load_HDF5('/root/projects/BrainTumor/dataset/2000.mat', 'tumorMask')
#
# d,p,r = dice_coeffecient(mask, tru_mask)
#
# print('Dice : ', d, '\n Precision : ', p, '\n Recall : ', r )
#
# plt.gray()
# plt.subplot(1,2,1)
# plt.imshow(mask)
# plt.subplot(1,2,2)
# plt.imshow(tru_mask)
# plt.show()
# Dice=[]
# Precision=[]
# Recall=[]
# data_dir='/root/projects/BrainTumor/newBrain/'
# hdf5_path='/root/projects/BrainTumor/dataset/'

# files = get_ordered_file_names(data_dir, '.nii.gz')

# for f in files:
# 	print('Processing this file :',f)
# 	IMG=get_nb_image(f)
# 	IVIFS = calc_IVIFS(IMG)
# 	kmeans=cluster.KMeans(n_clusters=4).fit(IVIFS)
# 	labels=kmeans.labels_
# 	i=0
# 	# Choosing the tumor cluster
# 	cluster_choice=''
# 	while cluster_choice=='':
# 		mask=get_tumor_mask(labels,i)
# 		i=i+1
# 		plt.imshow(mask)
# 		plt.show()
# 		cluster_choice = raw_input('Enter '' if wrong cluster, 0 otherwise: ')
# 		if cluster_choice=='q':
# 			cluster_choice=''
# 			i=i-1


# 	file_number=get_file_number(f)
# 	file_path=hdf5_path+str(file_number)+'.mat'

# 	tru_mask=load_HDF5(file_path, 'tumorMask')
# 	plt.subplot(1,2,1)
# 	plt.imshow(mask)
# 	plt.subplot(1,2,2)
# 	plt.imshow(tru_mask)

# 	temp=get_file_number(f)
# 	temp_='/root/projects/BrainTumor/compare/'+str(temp)+'.png'
# 	plt.savefig(temp_)
# 	plt.close()
# 	d,p,r = evaluate(mask, tru_mask)

# 	Dice.append(d)
# 	Precision.append(p)
# 	Recall.append(r)
# 	np.save('diceValue.npy', np.asarray(Dice))
# 	np.save('precision.npy',np.asarray(Precision))
# 	np.save('recall.npy',np.asarray(Recall))

# np.save('diceValueF.npy', np.asarray(Dice))
# np.save('precisionF.npy',np.asarray(Precision))
# np.save('recallF.npy',np.asarray(Recall))

# 	#print(Dice)
# plt.plot(Dice, label='DiceCoeffecient')
# plt.plot(Precision, label='Precision')
# plt.plot(Recall, label='Recall')
# plt.xlabel('Images')
# plt.title('Parameters for validating the model')
# plt.legend()
# plt.show()
# plt.close()


# d=np.load('diceVa')
# plt.ylabel('pixels ->')
# plt.title('image')
# plt.imshow(IMG)
# plt.show()

# median=median_filtering(IMG)

# plt.xlabel('pixels ->')
# plt.ylabel('pixels ->')
# plt.title('median')
# plt.imshow(median)
# plt.show()

# IHC=IHC(median)

# plt.xlabel('pixels ->')
# plt.ylabel('pixels ->')
# plt.title('IHC')
# plt.imshow(IHC)
# plt.show()

# gaussian_filtered=nd.gaussian_filter(IMG, 1.5)

# plt.xlabel('pixels ->')
# plt.ylabel('pixels ->')
# plt.title('gaussian_filtered')
# plt.imshow(gaussian_filtered)
# plt.show()

# edge=nd.sobel(gaussian_filtered)
# plt.xlabel('pixels ->')
# plt.ylabel('pixels ->')
# plt.title('sobel')
# plt.imshow(edge)
# plt.show()

plt.gray()
image=load_HDF5('/root/projects/BrainTumor/dataset/2700.mat', 'image')
image=np.asarray(image)
plt.imshow(image)
plt.show()
image_plot=image.flatten()
plt.ylabel('Pixel Intensities -->')
plt.xlabel('Pixels -->')
#plt.label('Raw image')
# plt.plot(image_plot, 'r', label='raw image')



unsharp, median=median_filtering(image)
# # plt.ylabel('Pixel Intensities -->')
# # plt.xlabel('Pixels -->')
# #plt.label('After median filtring')

plt.plot(median.flatten(), 'g', label= 'Median filter')
plt.plot(unsharp.flatten(),'b', label= ' Unsharp mask')
# IHC=IHC(median)
# IHC_plot=IHC.flatten()
# plt.plot(IHC_plot,'g', label='IHC ')

# gauss=nd.gaussian_filter(image, 1.5)
# plt.plot(gauss.flatten(), 'y', label='gaussian filter')



plt.legend()
plt.show()